//! Utilities for comparing and ordering values.
//!
//! This module contains various tools for comparing and ordering values. In
//! summary:
//!
//! * [`ContextualEq`] and [`ContextualPartialEq`] are traits that allow you to
//!   define total and partial equality between values, respectively.
//! * [`ContextualOrd`] and [`ContextualPartialOrd`] are traits that allow you to
//!   define total and partial orderings between values, respectively.
//!
//! For more details, see the respective documentation of each item in the list.

#[doc(no_inline)]
pub use core::cmp::Ordering;

use crate::NoContext;
use Ordering::*;

/// Trait for equality comparisons.
///
/// This trait allows for partial equality, for types that do not have a full
/// equivalence relation. For example, in floating point numbers `NaN != NaN`,
/// so floating point types may implement `ContextualPartialEq` but not [`ContextualEq`].
/// Formally speaking, when `Rhs == Self`, this trait corresponds to a [partial equivalence
/// relation](https://en.wikipedia.org/wiki/Partial_equivalence_relation).
///
/// Implementations must ensure that `contextual_eq` and `contextual_ne` are
/// consistent with each other:
///
/// - `a.contextual_ne(b, context)` if and only if `!a.contextual_eq(b, context)`.
///
/// The default implementation of `contextual_ne` provides this consistency and
/// is almost always sufficient. It should not be overridden without very good
/// reason.
///
/// If [`ContextualPartialOrd`] or [`ContextualOrd`] are also implemented for
/// `Self` and `Context` and `Rhs`, their methods must also be consistent with
/// `ContextualPartialEq` (see the documentation of those traits for the exact
/// requirements).
///
/// The equality relation `==` must satisfy the following conditions
/// (for all `a`, `b`, `c` of type `A`, `B`, `C`):
///
/// - **Symmetric**: if `A: ContextualPartialEq<Context, B>` and
///   `B: ContextualPartialEq<Context, A>`, then **`a.contextual_eq(b, context)`
///   implies `b.contextual_eq(a, context)`**;
///   and
///
/// - **Transitive**: if `A: ContextualPartialEq<Context, B>` and
///   `B: ContextualPartialEq<Context, C>` and `A: ContextualPartialEq<Context, C>`,
///   then **`a.contextual_eq(b, context)` and `b.contextual_eq(c, context)` implies
///   `a.contextual_eq(c, context)`**.
///
/// Note that the `B: ContextualPartialEq<Context, B>` (symmetric) and
/// `A: ContextualPartialEq<Context, C>` (transitive) impls are not forced to
/// exist, but these requirements apply whenever they do exist.
///
/// ## How can I implement `ContextualPartialEq`?
///
/// Implementations of this trait will be generated by the [`contextual`] macro
/// for equivalences that have been specified with an `eq` invocation and for
/// orders that have been specified with either a `partial_cmp` or a `cmp`
/// invocation.  Otherwise it can be manually implemented.
///
/// An example implementation for a domain in which two books are considered
/// the same book if their ISBN matches, even if the formats differ:
///
/// ```
/// use contextual_core::prelude::*;
///
/// enum BookFormat {
///     Paperback,
///     Hardback,
///     Ebook,
/// }
///
/// struct Book {
///     isbn: i32,
///     format: BookFormat,
/// }
///
/// impl ContextualPartialEq<NoContext> for Book {
///     fn contextual_eq(&self, other: &Self, _: &NoContext) -> bool {
///         self.isbn == other.isbn
///     }
/// }
///
/// let b1 = Book { isbn: 3, format: BookFormat::Paperback };
/// let b2 = Book { isbn: 3, format: BookFormat::Ebook };
/// let b3 = Book { isbn: 10, format: BookFormat::Paperback };
///
/// assert!(b1.contextual_eq(&b2, &NoContext));
/// assert!(b1.contextual_ne(&b3, &NoContext));
/// ```
///
/// ## How can I compare two different types?
///
/// The type you can compare with is controlled by `ContextualPartialEq`'s second
/// type parameter.  For example, let's tweak our previous code a bit:
///
/// ```
/// use contextual_core::prelude::*;
///
/// // The derive implements <BookFormat> == <BookFormat> comparisons
/// #[derive(PartialEq)]
/// enum BookFormat {
///     Paperback,
///     Hardback,
///     Ebook,
/// }
///
/// struct Book {
///     isbn: i32,
///     format: BookFormat,
/// }
///
/// // Implement <Book> == <BookFormat> comparisons
/// impl ContextualPartialEq<NoContext, BookFormat> for Book {
///     fn contextual_eq(&self, other: &BookFormat, _: &NoContext) -> bool {
///         self.format == *other
///     }
/// }
///
/// // Implement <BookFormat> == <Book> comparisons
/// impl ContextualPartialEq<NoContext, Book> for BookFormat {
///     fn contextual_eq(&self, other: &Book, _: &NoContext) -> bool {
///         *self == other.format
///     }
/// }
///
/// let b1 = Book { isbn: 3, format: BookFormat::Paperback };
///
/// assert!(b1.contextual_eq(&BookFormat::Paperback, &NoContext));
/// assert!(BookFormat::Ebook.contextual_ne(&b1, &NoContext));
/// ```
///
/// By changing `impl ContextualPartialEq<NoContext> for Book` to
/// `impl ContextualPartialEq<NoContext, BookFormat> for Book`, we allow
/// `BookFormat`s to be compared with `Book`s.
///
/// A comparison like the one above, which ignores some fields of the struct,
/// can be dangerous. It can easily lead to an unintended violation of the
/// requirements for a partial equivalence relation. For example, if we kept
/// the above implementation of `ContextualPartialEq<NoContext, Book>` for
/// `BookFormat` and added an implementation of `ContextualPartialEq<NoContext, Book>`
/// for `Book` (either via a `contextual` macro invocation or via the manual
/// implementation from the first example) then the result would violate
/// transitivity:
///
/// ```should_panic
/// use contextual_core::prelude::*;
///
/// #[derive(PartialEq)]
/// enum BookFormat {
///     Paperback,
///     Hardback,
///     Ebook,
/// }
///
/// #[derive(PartialEq)]
/// struct Book {
///     isbn: i32,
///     format: BookFormat,
/// }
///
/// impl ContextualPartialEq<NoContext, BookFormat> for Book {
///     fn contextual_eq(&self, other: &BookFormat, _: &NoContext) -> bool {
///         self.format == *other
///     }
/// }
///
/// impl ContextualPartialEq<NoContext, Book> for BookFormat {
///     fn contextual_eq(&self, other: &Book, _: &NoContext) -> bool {
///         *self == other.format
///     }
/// }
///
/// fn main() {
///     let b1 = Book { isbn: 1, format: BookFormat::Paperback };
///     let b2 = Book { isbn: 2, format: BookFormat::Paperback };
///
///     assert!(b1.contextual_eq(&BookFormat::Paperback, &NoContext));
///     assert!(BookFormat::Paperback.contextual_eq(&b2, &NoContext));
///
///     // The following should hold by transitivity but doesn't.
///     assert!(b1.contextual_eq(&b2, &NoContext)); // <-- PANICS
/// }
/// ```
///
/// # Examples
///
/// ```
/// let x: u32 = 0;
/// let y: u32 = 1;
///
/// assert_eq!(x == y, false);
/// assert_eq!(x.eq(&y), false);
/// ```
///
/// [`contextual`]: crate::contextual
#[allow(clippy::needless_doctest_main)]
pub trait ContextualPartialEq<Context: ?Sized = NoContext, Rhs: ?Sized = Self> {
    /// This method tests for `self` and `other` values to be equal.
    #[must_use]
    fn contextual_eq(&self, other: &Rhs, context: &Context) -> bool;

    /// This method tests for inequality. The default implementation is almost
    /// always sufficient, and should not be overridden without very good reason.
    #[inline]
    #[must_use]
    fn contextual_ne(&self, other: &Rhs, context: &Context) -> bool {
        !self.contextual_eq(other, context)
    }
}

/// Trait for equality comparisons which are [equivalence relations](
/// https://en.wikipedia.org/wiki/Equivalence_relation).
///
/// This means, that in addition to `a == b` and `a != b` being strict inverses, the equality must
/// be (for all `a`, `b` and `c`):
///
/// - reflexive: `a == a`;
/// - symmetric: `a == b` implies `b == a`; and
/// - transitive: `a == b` and `b == c` implies `a == c`.
///
/// This property cannot be checked by the compiler, and therefore `ContextualEq`
/// implies [`ContextualPartialEq`], and has no extra methods.
///
/// ## How can I implement `ContextualEq`?
///
/// Implementations of this trait will be generated by the [`contextual`] macro
/// for total orders that have been specified with a `cmp` invocation.
///
/// If you cannot use the `contextual` macro, specify that your type implements
/// `ContextualEq`, which has no methods:
///
/// ```
/// use contextual_core::prelude::*;
///
/// enum BookFormat { Paperback, Hardback, Ebook }
/// struct Book {
///     isbn: i32,
///     format: BookFormat,
/// }
/// impl ContextualPartialEq<NoContext> for Book {
///     fn contextual_eq(&self, other: &Self, _: &NoContext) -> bool {
///         self.isbn == other.isbn
///     }
/// }
/// impl ContextualEq<NoContext> for Book {}
/// ```
///
/// [`contextual`]: crate::contextual
pub trait ContextualEq<Context: ?Sized = NoContext>: ContextualPartialEq<Context, Self> {}

/// Trait for types that form a [total order](https://en.wikipedia.org/wiki/Total_order).
///
/// Implementations must be consistent with the [`ContextualPartialOrd`] implementation, and
/// ensure `contextual_max`, `contextual_min`, and `contextual_clamp` are consistent with
/// `contextual_cmp`:
///
/// - `contextual_partial_cmp(a, b, context) == Some(contextual_cmp(a, b, context))`.
/// - `matches!(contextual_max(a, b, context).contextual_cmp(a, context), Equal | Greater)`
///   (ensured by the default implementation).
/// - `matches!(contextual_max(a, b, context).contextual_cmp(b, context), Equal | Greater)`
///   (ensured by the default implementation).
/// - `matches!(contextual_min(a, b, context).contextual_cmp(a, context), Equal | Less)`
///   (ensured by the default implementation).
/// - `matches!(contextual_min(a, b, context).contextual_cmp(b, context), Equal | Less)`
///   (ensured by the default implementation).
/// - For `a.contextual_clamp(min, max, context)`, see the [method docs](#method.contextual_clamp)
///   (ensured by the default implementation).
///
/// ## Corollaries
///
/// From the above and the requirements of `ContextualPartialOrd`, it follows that `<` defines a
/// strict total order. This means that for all `a`, `b` and `c`:
///
/// - exactly one of `a < b`, `a == b` or `a > b` is true; and
/// - `<` is transitive: `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.
///
/// ## How can I implement `ContextualOrd`?
///
/// You must define an implementation for [`contextual_cmp`]. You may find it useful to use
/// [`contextual_cmp`] on your type's fields.
///
/// `ContextualOrd` requires that the type also be [`ContextualPartialOrd`] and [`ContextualEq`]
/// (which requires [`ContextualPartialEq`]).
///
/// Implementations of all these traits will be generated by the [`contextual`] macro
/// for total orders that have been specified with a `cmp` invocation.
///
/// Here's an example where you want to sort people by height only, disregarding `id`
/// and `name`:
///
/// ```
/// use contextual_core::prelude::*;
/// use std::cmp::Ordering;
///
/// struct Person {
///     id: u32,
///     name: String,
///     height: u32,
/// }
///
/// impl ContextualOrd<NoContext> for Person {
///     fn contextual_cmp(&self, other: &Self, context: &NoContext) -> Ordering {
///         self.height.contextual_cmp(&other.height, context)
///     }
/// }
///
/// impl ContextualPartialOrd<NoContext> for Person {
///     fn contextual_partial_cmp(&self, other: &Self, context: &NoContext) -> Option<Ordering> {
///         Some(self.contextual_cmp(other, context))
///     }
/// }
///
/// impl ContextualPartialEq<NoContext> for Person {
///     fn contextual_eq(&self, other: &Self, context: &NoContext) -> bool {
///         self.height.contextual_eq(&other.height, context)
///     }
/// }
///
/// impl ContextualEq<NoContext> for Person {}
/// ```
///
/// [`contextual`]: crate::contextual
/// [`contextual_cmp`]: ContextualOrd::contextual_cmp
pub trait ContextualOrd<Context: ?Sized = NoContext>:
    ContextualEq<Context> + ContextualPartialOrd<Context, Self>
{
    /// This method returns an [`Ordering`] between `self` and `other`.
    ///
    /// By convention, `self.contextual_cmp(&other, context)` returns the ordering matching the
    /// expression `self <operator> other` if true.
    ///
    /// # Examples
    ///
    /// ```
    /// use contextual_core::prelude::*;
    /// use std::cmp::Ordering;
    ///
    /// assert_eq!(5.contextual_cmp(&10, &NoContext), Ordering::Less);
    /// assert_eq!(10.contextual_cmp(&5, &NoContext), Ordering::Greater);
    /// assert_eq!(5.contextual_cmp(&5, &NoContext), Ordering::Equal);
    /// ```
    #[must_use]
    fn contextual_cmp(&self, other: &Self, context: &Context) -> Ordering;

    /// Compares and returns the maximum of two values.
    ///
    /// Returns the second argument if the comparison determines them to be equal.
    ///
    /// # Examples
    ///
    /// ```
    /// use contextual_core::prelude::*;
    ///
    /// assert_eq!(2, 1.contextual_max(2, &NoContext));
    /// assert_eq!(2, 2.contextual_max(2, &NoContext));
    /// ```
    #[inline]
    #[must_use]
    fn contextual_max(self, other: Self, context: &Context) -> Self
    where
        Self: Sized,
    {
        match self.contextual_cmp(&other, context) {
            Less | Equal => other,
            Greater => self,
        }
    }

    /// Compares and returns the minimum of two values.
    ///
    /// Returns the first argument if the comparison determines them to be equal.
    ///
    /// # Examples
    ///
    /// ```
    /// use contextual_core::prelude::*;
    ///
    /// assert_eq!(1, 1.contextual_min(2, &NoContext));
    /// assert_eq!(2, 2.contextual_min(2, &NoContext));
    /// ```
    #[inline]
    #[must_use]
    fn contextual_min(self, other: Self, context: &Context) -> Self
    where
        Self: Sized,
    {
        match self.contextual_cmp(&other, context) {
            Less | Equal => self,
            Greater => other,
        }
    }

    /// Restrict a value to a certain interval.
    ///
    /// Returns `max` if `self` is greater than `max`, and `min` if `self` is
    /// less than `min`. Otherwise this returns `self`.
    ///
    /// # Panics
    ///
    /// Panics if `min > max`.
    ///
    /// # Examples
    ///
    /// ```
    /// use contextual_core::prelude::*;
    ///
    /// assert!((-3).contextual_clamp(-2, 1, &NoContext) == -2);
    /// assert!(0.contextual_clamp(-2, 1, &NoContext) == 0);
    /// assert!(2.contextual_clamp(-2, 1, &NoContext) == 1);
    /// ```
    #[must_use]
    fn contextual_clamp(self, min: Self, max: Self, context: &Context) -> Self
    where
        Self: Sized,
    {
        assert!(self.contextual_le(&max, context));
        if self.contextual_lt(&min, context) {
            min
        } else if self.contextual_gt(&max, context) {
            max
        } else {
            self
        }
    }
}

/// Trait for types that form a [partial order](https://en.wikipedia.org/wiki/Partial_order).
///
/// The methods of this trait must be consistent with each other and with those of
/// [`ContextualPartialEq`].  The following conditions must hold:
///
/// 1. `a == b` if and only if `contextual_partial_cmp(a, b, context) == Some(Equal)`.
/// 2. `a < b` if and only if `contextual_partial_cmp(a, b, context) == Some(Less)`
/// 3. `a > b` if and only if `contextual_partial_cmp(a, b, context) == Some(Greater)`
/// 4. `a <= b` if and only if `a < b || a == b`
/// 5. `a >= b` if and only if `a > b || a == b`
/// 6. `a != b` if and only if `!(a == b)`.
///
/// Conditions 2–5 above are ensured by the default implementation.
/// Condition 6 is already ensured by [`ContextualPartialEq`].
///
/// If [`ContextualOrd`] is also implemented for `Self`, `Context` and `Rhs`, it must also
/// be consistent with `contextual_partial_cmp` (see the documentation of that trait for the
/// exact requirements).
///
/// The comparison must satisfy, for all `a`, `b` and `c`:
///
/// - transitivity: `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.
/// - duality: `a < b` if and only if `b > a`.
///
/// Note that these requirements mean that the trait itself must be implemented symmetrically and
/// transitively: if `T: ContextualPartialOrd<Context, U>` and `U: ContextualPartialOrd<Context, V>`
/// then `U: ContextualPartialOrd<Context, T>` and `T: ContextualPartialOrd<Context, V>`.
///
/// ## Corollaries
///
/// The following corollaries follow from the above requirements:
///
/// - irreflexivity of `<` and `>`: `!(a < a)`, `!(a > a)`
/// - transitivity of `>`: if `a > b` and `b > c` then `a > c`
/// - duality of `contextual_partial_cmp`:
///   `contextual_partial_cmp(a, b, context) == contextual_partial_cmp(b, a, context).map(Ordering::reverse)`
///
/// ## How can I implement `ContextualPartialOrd`?
///
/// `ContextualPartialOrd` only requires implementation of the [`contextual_partial_cmp`] method,
/// with the others generated from default implementations.
///
/// However it remains possible to implement the others separately for types which do not have a
/// total order. For example, for floating point numbers, `NaN < 0 == false` and `NaN >= 0 ==
/// false` (cf. IEEE 754-2008 section 5.11).
///
/// `ContextualPartialOrd` requires your type to be [`ContextualPartialEq`].
///
/// Implementations of both these traits will be generated by the [`contextual`] macro
/// for partial orders that have been specified with a `partial_cmp` invocation.
///
/// If your type is [`ContextualOrd`], you can implement [`contextual_partial_cmp`] by using [`contextual_cmp`].
///
/// ```
/// use contextual_core::prelude::*;
/// use std::cmp::Ordering;
///
/// struct Person {
///     id: u32,
///     name: String,
///     height: u32,
/// }
///
/// impl ContextualPartialOrd<NoContext> for Person {
///     fn contextual_partial_cmp(&self, other: &Self, context: &NoContext) -> Option<Ordering> {
///         Some(self.contextual_cmp(other, context))
///     }
/// }
///
/// impl ContextualOrd<NoContext> for Person {
///     fn contextual_cmp(&self, other: &Self, context: &NoContext) -> Ordering {
///         self.height.contextual_cmp(&other.height, context)
///     }
/// }
///
/// impl ContextualPartialEq<NoContext> for Person {
///     fn contextual_eq(&self, other: &Self, context: &NoContext) -> bool {
///         self.height.contextual_eq(&other.height, context)
///     }
/// }
///
/// impl ContextualEq<NoContext> for Person {}
/// ```
///
/// You may also find it useful to use [`contextual_partial_cmp`] on your type's fields.
/// Here is an example of `Person` types who have a floating-point `height` field that
/// is the only field to be used for sorting:
///
/// ```
/// use contextual_core::prelude::*;
/// use std::cmp::Ordering;
///
/// struct Person {
///     id: u32,
///     name: String,
///     height: f64,
/// }
///
/// impl ContextualPartialOrd<NoContext> for Person {
///     fn contextual_partial_cmp(&self, other: &Self, context: &NoContext) -> Option<Ordering> {
///         self.height.contextual_partial_cmp(&other.height, context)
///     }
/// }
///
/// impl ContextualPartialEq<NoContext> for Person {
///     fn contextual_eq(&self, other: &Self, context: &NoContext) -> bool {
///         self.height.contextual_eq(&other.height, context)
///     }
/// }
/// ```
///
/// # Examples
///
/// ```
/// use contextual_core::prelude::*;
///
/// let x: u32 = 0;
/// let y: u32 = 1;
///
/// assert_eq!(x.contextual_lt(&y, &NoContext), true);
/// ```
///
/// [`contextual`]: crate::contextual
/// [`contextual_partial_cmp`]: ContextualPartialOrd::contextual_partial_cmp
/// [`contextual_cmp`]: ContextualOrd::contextual_cmp
pub trait ContextualPartialOrd<Context: ?Sized = NoContext, Rhs: ?Sized = Self>:
    ContextualPartialEq<Context, Rhs>
{
    /// This method returns an ordering between `self` and `other` values if one exists.
    ///
    /// # Examples
    ///
    /// ```
    /// use contextual_core::prelude::*;
    /// use std::cmp::Ordering;
    ///
    /// let result = 1.0.contextual_partial_cmp(&2.0, &NoContext);
    /// assert_eq!(result, Some(Ordering::Less));
    ///
    /// let result = 1.0.contextual_partial_cmp(&1.0, &NoContext);
    /// assert_eq!(result, Some(Ordering::Equal));
    ///
    /// let result = 2.0.contextual_partial_cmp(&1.0, &NoContext);
    /// assert_eq!(result, Some(Ordering::Greater));
    /// ```
    ///
    /// When comparison is impossible:
    ///
    /// ```
    /// use contextual_core::prelude::*;
    ///
    /// let result = f64::NAN.contextual_partial_cmp(&1.0, &NoContext);
    /// assert_eq!(result, None);
    /// ```
    #[must_use]
    fn contextual_partial_cmp(&self, other: &Rhs, context: &Context) -> Option<Ordering>;

    /// This method tests less than (for `self` and `other`).
    ///
    /// # Examples
    ///
    /// ```
    /// use contextual_core::prelude::*;
    ///
    /// let result = 1.0.contextual_lt(&2.0, &NoContext);
    /// assert_eq!(result, true);
    ///
    /// let result = 2.0.contextual_lt(&1.0, &NoContext);
    /// assert_eq!(result, false);
    /// ```
    #[inline]
    #[must_use]
    fn contextual_lt(&self, other: &Rhs, context: &Context) -> bool {
        matches!(self.contextual_partial_cmp(other, context), Some(Less))
    }

    /// This method tests less than or equal to (for `self` and `other`).
    ///
    /// # Examples
    ///
    /// ```
    /// use contextual_core::prelude::*;
    ///
    /// let result = 1.0.contextual_le(&2.0, &NoContext);
    /// assert_eq!(result, true);
    ///
    /// let result = 2.0.contextual_le(&2.0, &NoContext);
    /// assert_eq!(result, true);
    /// ```
    #[inline]
    #[must_use]
    fn contextual_le(&self, other: &Rhs, context: &Context) -> bool {
        matches!(self.contextual_partial_cmp(other, context), Some(Less | Equal))
    }

    /// This method tests greater than (for `self` and `other`).
    ///
    /// # Examples
    ///
    /// ```
    /// use contextual_core::prelude::*;
    ///
    /// let result = 1.0.contextual_gt(&2.0, &NoContext);
    /// assert_eq!(result, false);
    ///
    /// let result = 2.0.contextual_gt(&2.0, &NoContext);
    /// assert_eq!(result, false);
    /// ```
    #[inline]
    #[must_use]
    fn contextual_gt(&self, other: &Rhs, context: &Context) -> bool {
        matches!(self.contextual_partial_cmp(other, context), Some(Greater))
    }

    /// This method tests greater than or equal to (for `self` and `other`).
    ///
    /// # Examples
    ///
    /// ```
    /// use contextual_core::prelude::*;
    ///
    /// let result = 2.0.contextual_ge(&1.0, &NoContext);
    /// assert_eq!(result, true);
    ///
    /// let result = 2.0.contextual_ge(&2.0, &NoContext);
    /// assert_eq!(result, true);
    /// ```
    #[inline]
    #[must_use]
    fn contextual_ge(&self, other: &Rhs, context: &Context) -> bool {
        matches!(self.contextual_partial_cmp(other, context), Some(Greater | Equal))
    }
}
